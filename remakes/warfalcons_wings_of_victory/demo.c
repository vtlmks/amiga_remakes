// Copyright (c) 2025 Peter Fors
// SPDX-License-Identifier: MIT


INCBIN_UGG(bob01, "data/bob_01.ugg");
INCBIN_UGG(bob02, "data/bob_02.ugg");
INCBIN_UGG(bob03, "data/bob_03.ugg");
INCBIN_UGG(bob04, "data/bob_04.ugg");
INCBIN_UGG(bob05, "data/bob_05.ugg");
INCBIN_UGG(bob06, "data/bob_06.ugg");
INCBIN_UGG(bob07, "data/bob_07.ugg");
INCBIN_UGG(bob08, "data/bob_08.ugg");
INCBIN_UGG(bob09, "data/bob_09.ugg");
INCBIN_UGG(bob0a, "data/bob_0a.ugg");
INCBIN_UGG(bob0b, "data/bob_0b.ugg");
INCBIN_UGG(bob0c, "data/bob_0c.ugg");
INCBIN_UGG(bob0d, "data/bob_0d.ugg");
INCBIN_UGG(bob11, "data/bob_11.ugg");
INCBIN_UGG(bob12, "data/bob_12.ugg");
INCBIN_UGG(bob13, "data/bob_13.ugg");
INCBIN_UGG(bob14, "data/bob_14.ugg");
INCBIN_UGG(bob15, "data/bob_15.ugg");
INCBIN_UGG(bob16, "data/bob_16.ugg");
INCBIN_UGG(bob17, "data/bob_17.ugg");
INCBIN_UGG(bob18, "data/bob_18.ugg");
INCBIN_UGG(bob19, "data/bob_19.ugg");
INCBIN_UGG(bob1a, "data/bob_1a.ugg");
INCBIN_UGG(bob1b, "data/bob_1b.ugg");
INCBIN_UGG(bob1c, "data/bob_1c.ugg");
INCBIN_UGG(bob1d, "data/bob_1d.ugg");
INCBIN_UGG(bob21, "data/bob_21.ugg");
INCBIN_UGG(bob22, "data/bob_22.ugg");
INCBIN_UGG(bob23, "data/bob_23.ugg");
INCBIN_UGG(bob24, "data/bob_24.ugg");
INCBIN_UGG(bob25, "data/bob_25.ugg");
INCBIN_UGG(bob26, "data/bob_26.ugg");
INCBIN_UGG(bob27, "data/bob_27.ugg");
INCBIN_UGG(bob28, "data/bob_28.ugg");
INCBIN_UGG(bob29, "data/bob_29.ugg");
INCBIN_UGG(bob2a, "data/bob_2a.ugg");
INCBIN_UGG(bob2b, "data/bob_2b.ugg");
INCBIN_UGG(bob2c, "data/bob_2c.ugg");
INCBIN_UGG(bob2d, "data/bob_2d.ugg");
INCBIN_UGG(bob31, "data/bob_31.ugg");
INCBIN_UGG(bob32, "data/bob_32.ugg");
INCBIN_UGG(bob33, "data/bob_33.ugg");
INCBIN_UGG(bob34, "data/bob_34.ugg");
INCBIN_UGG(bob35, "data/bob_35.ugg");
INCBIN_UGG(bob36, "data/bob_36.ugg");
INCBIN_UGG(bob37, "data/bob_37.ugg");
INCBIN_UGG(bob38, "data/bob_38.ugg");
INCBIN_UGG(bob39, "data/bob_39.ugg");
INCBIN_UGG(bob3a, "data/bob_3a.ugg");
INCBIN_UGG(bob3b, "data/bob_3b.ugg");
INCBIN_UGG(bob3c, "data/bob_3c.ugg");
INCBIN_UGG(bob3d, "data/bob_3d.ugg");

INCBIN_UGG(font, "data/font.ugg");
INCBIN_UGG(logo, "data/warfalcons_logo.ugg");

static const int16_t wf_sine_table[320] = {
	0x0000, 0x0192, 0x0324, 0x04b5, 0x0645, 0x07d5, 0x0963, 0x0af0, 0x0c7b, 0x0e05, 0x0f8c, 0x1111, 0x1293, 0x1412, 0x158e, 0x1707,
	0x187c, 0x19ee, 0x1b5b, 0x1cc4, 0x1e29, 0x1f89, 0x20e5, 0x223b, 0x238c, 0x24d8, 0x261d, 0x275d, 0x2897, 0x29cb, 0x2af8, 0x2c1f,
	0x2d3e, 0x2e57, 0x2f69, 0x3073, 0x3176, 0x3271, 0x3365, 0x3451, 0x3534, 0x360f, 0x36e2, 0x37ad, 0x386f, 0x3928, 0x39d9, 0x3a80,
	0x3b1f, 0x3bb4, 0x3c40, 0x3cc3, 0x3d3d, 0x3dad, 0x3e13, 0x3e70, 0x3ec4, 0x3f0e, 0x3f4e, 0x3f84, 0x3fb0, 0x3fd3, 0x3fec, 0x3ffb,

	0x4000, 0x3ffb, 0x3fed, 0x3fd4, 0x3fb2, 0x3f86, 0x3f50, 0x3f10, 0x3ec7, 0x3e74, 0x3e17, 0x3db1, 0x3d41, 0x3cc8, 0x3c46, 0x3bba,
	0x3b25, 0x3a86, 0x39df, 0x392f, 0x3876, 0x37b5, 0x36ea, 0x3618, 0x353d, 0x345a, 0x336e, 0x327b, 0x3180, 0x307e, 0x2f74, 0x2e62,
	0x2d4a, 0x2c2a, 0x2b04, 0x29d7, 0x28a3, 0x276a, 0x262a, 0x24e4, 0x2399, 0x2248, 0x20f2, 0x1f97, 0x1e37, 0x1cd2, 0x1b69, 0x19fc,
	0x188b, 0x1716, 0x159d, 0x1421, 0x12a2, 0x1120, 0x0f9b, 0x0e14, 0x0c8b, 0x0b00, 0x0973, 0x07e5, 0x0655, 0x04c5, 0x0334, 0x01a2,

	0x0010, 0xfe7e, 0xfcec, 0xfb5b, 0xf9ca, 0xf83b, 0xf6ac, 0xf51f, 0xf394, 0xf20b, 0xf084, 0xeeff, 0xed7d, 0xebfd, 0xea81, 0xe908,
	0xe793, 0xe621, 0xe4b3, 0xe34a, 0xe1e5, 0xe084, 0xdf29, 0xddd2, 0xdc81, 0xdb35, 0xd9ef, 0xd8af, 0xd775, 0xd641, 0xd514, 0xd3ed,
	0xd2cd, 0xd1b4, 0xd0a2, 0xcf97, 0xce94, 0xcd98, 0xcca5, 0xcbb9, 0xcad5, 0xc9f9, 0xc926, 0xc85b, 0xc799, 0xc6df, 0xc62e, 0xc586,
	0xc4e8, 0xc452, 0xc3c5, 0xc342, 0xc2c8, 0xc257, 0xc1f1, 0xc193, 0xc13f, 0xc0f5, 0xc0b5, 0xc07e, 0xc051, 0xc02e, 0xc015, 0xc006,

	0xc000, 0xc004, 0xc013, 0xc02b, 0xc04d, 0xc078, 0xc0ae, 0xc0ed, 0xc136, 0xc189, 0xc1e5, 0xc24b, 0xc2ba, 0xc333, 0xc3b5, 0xc441,
	0xc4d5, 0xc573, 0xc61a, 0xc6ca, 0xc782, 0xc844, 0xc90d, 0xc9e0, 0xcaba, 0xcb9d, 0xcc88, 0xcd7b, 0xce76, 0xcf78, 0xd082, 0xd193,
	0xd2ab, 0xd3ca, 0xd4f0, 0xd61d, 0xd750, 0xd88a, 0xd9c9, 0xdb0f, 0xdc5a, 0xddaa, 0xdf00, 0xe05b, 0xe1bb, 0xe31f, 0xe488, 0xe5f5,
	0xe767, 0xe8dc, 0xea54, 0xebd0, 0xed4f, 0xeed1, 0xf055, 0xf1dc, 0xf366, 0xf4f1, 0xf67d, 0xf80c, 0xf99b, 0xfb2b, 0xfcbd, 0xfe4e,

	0x0000, 0x0192, 0x0324, 0x04b5, 0x0645, 0x07d5, 0x0963, 0x0af0, 0x0c7b, 0x0e05, 0x0f8c, 0x1111, 0x1293, 0x1412, 0x158e, 0x1707,
	0x187c, 0x19ee, 0x1b5b, 0x1cc4, 0x1e29, 0x1f89, 0x20e5, 0x223b, 0x238c, 0x24d8, 0x261d, 0x275d, 0x2897, 0x29cb, 0x2af8, 0x2c1f,
	0x2d3e, 0x2e57, 0x2f69, 0x3073, 0x3176, 0x3271, 0x3365, 0x3451, 0x3534, 0x360f, 0x36e2, 0x37ad, 0x386f, 0x3928, 0x39d9, 0x3a80,
	0x3b1f, 0x3bb4, 0x3c40, 0x3cc3, 0x3d3d, 0x3dad, 0x3e13, 0x3e70, 0x3ec4, 0x3f0e, 0x3f4e, 0x3f84, 0x3fb0, 0x3fd3, 0x3fec, 0x3ffb,
};
#define cosine_table (sine_table + 64)		// Cosine table (sine table shifted by 90 degrees)

uint32_t angle_x = 0;
uint32_t angle_y = 0;
uint32_t angle_z = 0;

static int16_t vec_obj_0[] = {	// 20
	0x001b,0xffdd,0xffdd,0x0023,
	0x001b,0x0023,0xffdd,0x0023,
	0x001b,0xffdd,0xffdd,0xffdd,
	0x001b,0x0023,0xffdd,0xffdd,
	0x0028,0xffdd,0x0023,0x0023,
	0x0028,0x0023,0x0023,0x0023,
	0x0028,0xffdd,0x0023,0xffdd,
	0x0028,0x0023,0x0023,0xffdd,
	0x000e,0x0000,0x0023,0x0023,
	0x000e,0x0000,0xffdd,0x0023,
	0x000e,0x0000,0xffdd,0xffdd,
	0x000e,0xffdd,0xffdd,0x0000,
	0x000e,0x0023,0xffdd,0x0000,
	0x000e,0xffdd,0x0000,0x0023,
	0x0001,0x0023,0x0000,0x0023,
	0x0001,0xffdd,0x0000,0xffdd,
	0x0001,0x0023,0x0000,0xffdd,
	0x0001,0x0000,0x0023,0xffdd,
	0x0001,0xffdd,0x0023,0x0000,
	0x0001,0x0023,0x0023,0x0000,
};

static int16_t vec_obj_1[] = {	// 35
	0x0010,0x0000,0x0000,0x0000,
	0x0010,0x0000,0x000c,0x0000,
	0x0010,0x0000,0x0018,0x0000,
	0x0010,0x0000,0xfff4,0x0000,
	0x0010,0x0000,0xffe8,0x0000,
	0x0010,0x0018,0x0000,0x0000,
	0x0010,0x0018,0x000c,0x0000,
	0x0010,0x0018,0x0018,0x0000,
	0x0010,0x0018,0xfff4,0x0000,
	0x0010,0x0018,0xffe8,0x0000,
	0x0010,0xffe8,0x0000,0x0000,
	0x0010,0xffe8,0x000c,0x0000,
	0x0010,0xffe8,0x0018,0x0000,
	0x0010,0xffe8,0xfff4,0x0000,
	0x0010,0xffe8,0xffe8,0x0000,
	0x0010,0x000c,0xffe8,0x0000,
	0x0010,0xfff4,0xffe8,0x0000,
	0x0003,0x0030,0x0000,0x0000,
	0x0003,0x0030,0x000c,0x0000,
	0x0003,0x0030,0x0018,0x0000,
	0x0003,0x0030,0xfff4,0x0000,
	0x0003,0x0030,0xfff4,0x0000,
	0x0003,0x003c,0x0000,0x0000,
	0x0003,0x003c,0x0018,0x0000,
	0x0003,0x0048,0x0000,0x0000,
	0x0003,0x0048,0x0018,0x0000,
	0x001d,0xffc4,0xffe8,0x0000,
	0x001d,0xffc4,0xfff4,0x0000,
	0x001d,0xffc4,0x000c,0x0000,
	0x001d,0xffc4,0x0018,0x0000,
	0x001d,0xffdc,0x0018,0x0000,
	0x001d,0xffd0,0x0018,0x0000,
	0x001d,0xffb8,0x0018,0x0000,
	0x001d,0xffac,0x0018,0x0000,
	0x0003,0x0024,0x0018,0x0000,
};

static int16_t vec_obj_2[] = {	// 20
	0x000f,0xffec,0xffec,0x0014,
	0x000f,0x0014,0xffec,0x0014,
	0x0004,0x0000,0xffec,0x0014,
	0x000f,0xffec,0xffec,0xffec,
	0x000f,0x0014,0xffec,0xffec,
	0x0004,0x0000,0xffec,0xffec,
	0x0004,0xffec,0xffec,0x0000,
	0x0004,0x0014,0xffec,0x0000,
	0x001e,0xffec,0x0000,0x0014,
	0x001e,0x0014,0x0000,0x0014,
	0x001e,0xffec,0x0000,0xffec,
	0x001e,0x0014,0x0000,0xffec,
	0x000f,0xffec,0x0014,0x0014,
	0x000f,0x0014,0x0014,0x0014,
	0x0004,0x0000,0x0014,0x0014,
	0x000f,0xffec,0x0014,0xffec,
	0x000f,0x0014,0x0014,0xffec,
	0x002b,0x0000,0x0014,0xffec,
	0x002b,0xffec,0x0014,0x0000,
	0x002b,0x0014,0x0014,0x0000,
};

static int16_t vec_obj_3[] = {	// 15
	0x001a,0x0000,0x0000,0x0000,
	0x0004,0xfff0,0x0010,0xffee,
	0x0004,0x0010,0x0010,0xffee,
	0x0004,0xfff0,0xfff0,0xffee,
	0x0004,0x0010,0xfff0,0xffee,
	0x0002,0x001d,0x0000,0xfff8,
	0x0003,0x002a,0x0000,0xfff3,
	0x0004,0x0035,0x0000,0xffee,
	0x0005,0x003e,0x0000,0xffec,
	0x0003,0xffe5,0x0000,0x000b,
	0x0004,0xffda,0x0000,0x0014,
	0x0004,0xffd6,0x0000,0x001e,
	0x0005,0xffd6,0x0000,0x0028,
	0x0003,0xffd6,0x0000,0x0035,
	0x0006,0xffcc,0x0000,0x0035,
};

static int16_t vec_obj_4[] = {	// 19
	0x0000,0x0000,0x0000,0x0008,
	0x0014,0xfffc,0x0014,0x0006,
	0x0014,0x0004,0x0014,0x0006,
	0x0004,0x0000,0x0000,0xffea,
	0x0005,0x0000,0x0000,0xffdf,
	0x0005,0xfff6,0x0000,0xffea,
	0x0005,0x000a,0x0000,0xffea,
	0x0005,0xffec,0x0000,0xffe4,
	0x0005,0x0014,0x0000,0xffe4,
	0x0005,0xffe6,0x0000,0xffd8,
	0x0005,0x001a,0x0000,0xffd8,
	0x0004,0x0000,0x0000,0xffd3,
	0x0005,0x0000,0x0000,0xffcc,
	0x0005,0xfff6,0x0000,0xffc8,
	0x0005,0x000a,0x0000,0xffc8,
	0x0005,0xffec,0x0000,0xffc2,
	0x0005,0x0014,0x0000,0xffc2,
	0x0002,0xffe2,0x0000,0xffba,
	0x0002,0x001e,0x0000,0xffba,
};

static int16_t vec_obj_5[] = {	// 20
	0x000f,0xffec,0xffec,0x0014,
	0x000f,0x0014,0xffec,0x0014,
	0x0004,0x0000,0xffec,0x0014,
	0x000f,0xffec,0xffec,0xffec,
	0x000f,0x0014,0xffec,0xffec,
	0x0004,0x0000,0xffec,0xffec,
	0x0004,0xffec,0xffec,0x0000,
	0x0004,0x0014,0xffec,0x0000,
	0x001e,0xffec,0x0000,0x0014,
	0x001e,0x0014,0x0000,0x0014,
	0x001e,0xffec,0x0000,0xffec,
	0x001e,0x0014,0x0000,0xffec,
	0x000f,0xffec,0x0014,0x0014,
	0x000f,0x0014,0x0014,0x0014,
	0x0004,0x0000,0x0014,0x0014,
	0x000f,0xffec,0x0014,0xffec,
	0x000f,0x0014,0x0014,0xffec,
	0x002b,0x0000,0x0014,0xffec,
	0x002b,0xffec,0x0014,0x0000,
	0x002b,0x0014,0x0014,0x0000,
};

static int16_t vec_obj_6[] = {	// 20
	0x000e,0xffdd,0xffdd,0x0023,
	0x000e,0x0023,0xffdd,0x0023,
	0x0001,0xffdd,0xffdd,0xffdd,
	0x0001,0x0023,0xffdd,0xffdd,
	0x0028,0xffdd,0x0023,0x0023,
	0x0028,0x0023,0x0023,0x0023,
	0x0028,0xffdd,0x0023,0xffdd,
	0x0028,0x0023,0x0023,0xffdd,
	0x000e,0x0000,0x0023,0x0023,
	0x000e,0x0000,0xffdd,0x0023,
	0x000e,0x0000,0xffdd,0xffdd,
	0x000e,0xffdd,0xffdd,0x0000,
	0x000e,0x0023,0xffdd,0x0000,
	0x000e,0xffdd,0x0000,0x0023,
	0x001b,0x0023,0x0000,0x0023,
	0x001b,0xffdd,0x0000,0xffdd,
	0x001b,0x0023,0x0000,0xffdd,
	0x001b,0x0000,0x0023,0xffdd,
	0x001b,0xffdd,0x0023,0x0000,
	0x001b,0x0023,0x0023,0x0000,
};

static int16_t vec_obj_7[] = {	// 27
	0x0002,0xffda,0xffda,0x0026,
	0x000f,0x0000,0xffda,0x0026,
	0x0002,0x0026,0xffda,0x0026,
	0x000f,0xffda,0xffda,0x0000,
	0x0002,0x0000,0xffda,0x0000,
	0x000f,0x0026,0xffda,0x0000,
	0x0002,0xffda,0xffda,0xffda,
	0x000f,0x0000,0xffda,0xffda,
	0x0002,0x0026,0xffda,0xffda,
	0x000f,0xffda,0x0000,0x0026,
	0x0002,0x0000,0x0000,0x0026,
	0x000f,0x0026,0x0000,0x0026,
	0x0002,0xffda,0x0000,0x0000,
	0x000f,0x0000,0x0000,0x0000,
	0x0002,0x0026,0x0000,0x0000,
	0x000f,0xffda,0x0000,0xffda,
	0x0002,0x0000,0x0000,0xffda,
	0x000f,0x0026,0x0000,0xffda,
	0x0002,0xffda,0x0026,0x0026,
	0x000f,0x0000,0x0026,0x0026,
	0x0002,0x0026,0x0026,0x0026,
	0x000f,0xffda,0x0026,0x0000,
	0x0002,0x0000,0x0026,0x0000,
	0x000f,0x0026,0x0026,0x0000,
	0x0002,0xffda,0x0026,0xffda,
	0x000f,0x0000,0x0026,0xffda,
	0x0002,0x0026,0x0026,0xffda,
};

struct object {
	int16_t *vec_obj;
	uint32_t count;
};

struct object objects[] = {
	{ vec_obj_0, 20 },
	{ vec_obj_1, 35 },
	{ vec_obj_2, 20 },
	{ vec_obj_3, 15 },
	{ vec_obj_4, 19 },
	{ vec_obj_5, 20 },
	{ vec_obj_6, 20 },
	{ vec_obj_7, 27 },
};

struct vec_coord {
	uint32_t object;
	int32_t x;
	int32_t y;
	int32_t z;
};

static void transform_and_project(int16_t *vertices, struct vec_coord *output, int num_vertices, int32_t angle_x, int32_t angle_y, int32_t angle_z) {
	int32_t tx;
	int32_t ty;
	int32_t tz;

	int32_t sx = wf_sine_table[angle_x];
	int32_t cx = wf_sine_table[(angle_x + 64) & 0xff];
	int32_t sy = wf_sine_table[angle_y];
	int32_t cy = wf_sine_table[(angle_y + 64) & 0xff];
	int32_t sz = wf_sine_table[angle_z];
	int32_t cz = wf_sine_table[(angle_z + 64) & 0xff];

	int32_t projection_distance = 230;
	int32_t screen_distance = 300;
	int32_t screen_x_offset = 160;
	int32_t screen_y_offset = 135;

	for(int i = 0; i < num_vertices; i++) {
		output[i].object = *vertices++;

		int32_t x = *vertices++ + 20;
		int32_t y = *vertices++ + 40;
		int32_t z = *vertices++ + 60;

		ty = ((y * cx - z * sx) >> 14);
		tz = ((y * sx + z * cx) >> 14);
		y = ty;
		z = tz;

		tx = ((x * cy + z * sy) >> 14);
		tz = ((z * cy - x * sy) >> 14);
		x = tx;
		z = tz;

		tx = ((x * cz - y * sz) >> 14);
		ty = ((x * sz + y * cz) >> 14);
		x = tx;
		y = ty;

		int32_t screen_x = (x * projection_distance) / (z + screen_distance) + screen_x_offset;
		int32_t screen_y = (y * projection_distance) / (z + screen_distance) + screen_y_offset;

		output[i].x = screen_x;
		output[i].y = screen_y;
		output[i].z = z;
	}
}


struct vec_coord vec_coords[50];

void sort_vec_coord(struct vec_coord *arr, uint32_t count) {
	if(count == 0) __builtin_unreachable();

	for(uint32_t i = 1; i < count; i++) {
		struct vec_coord key = arr[i];
		int32_t j = i - 1;

		// Move elements greater than key.object forward
		while(j >= 0 && arr[j].z < key.z) {
			arr[j + 1] = arr[j];
			j--;
		}

		// Place key in the correct position
		arr[j + 1] = key;
	}
}


static uint8_t text[] = {
	"              <WARFALCONS>              "
	"                                        "
	"            PROUDLY PRESENTS            "
	"                                        "
	"           <WINGS OF VICTORY>           "
	"                                        "
	"          CODING BY MASTER ACE          "
	"                                        "
	"          PIXELATION BY LO-RES          "
	"                                        "
	"        LOGO BY SCAMP AND LO-RES        "
	"                                        "
	"            MUSIC BY EINSTEIN           "
	"                                        "
	"         RELEASED FEBRUARY 18TH         "
	"                                        "
	"      ON DEXION-KEFRENS COPY-PARTY      "
	"                                        "
	"     MEMBERS OF THE WARFALCONS ARE:     "
	"                                        "
	"  ANTICHRIST (HYPOCRATIC HYPOCONDRIAC)  "
	"                                        "
	"           BYTEBUSTER (CODER)           "
	"                                        "
	"      CAT (MAIL AND MODEM-SWAPPER)      "
	"                                        "
	"       EDDIE (GRAPHICS AND MUSIC)       "
	"                                        "
	"   EINSTEIN (MUSIC AND MAIL-SWAPPER)    "
	"                                        "
	"           LO-RES (GRAPHICS)            "
	"                                        "
	"     MASTER ACE (CODER AND TRAINER)     "
	"                                        "
	"           SCAMP (GRAPHICS)             "
	"                                        "
	"           SHOWNUFF (CODER)             "
	"                                        "
	"                                        "
	"  CONTACT US AT ONE OF THESE ADRESSES:  "
	"                                        "
	"               WARFALCONS               "
	"               WARFALCONS               "
	"             POSTE/RESTANTE             "
	"             POSTE/RESTANTE             "
	"              6720 NORDBY               "
	"              6720 NORDBY               "
	"                DENMARK                 "
	"                DENMARK                 "
	"                                        "
	"               WARFALCONS               "
	"               WARFALCONS               "
	"             POSTE/RESTANTE             "
	"             POSTE/RESTANTE             "
	"        7000 ERRITSO, FREDERICIA        "
	"        7000 ERRITSO, FREDERICIA        "
	"                DENMARK                 "
	"                DENMARK                 "
	"                                        "
	"               WARFALCONS               "
	"               WARFALCONS               "
	"               P.O BOX 28               "
	"               P.O BOX 28               "
	"             3760  GUDHJEM              "
	"             3760  GUDHJEM              "
	"                DENMARK                 "
	"                DENMARK                 "
	"                                        "
	"        SEE YA IN HELL SUCKERS!         "
	"                                        "
	"                                        "
	"\0"
};

// render one text-line, 40 characters, one by one, wait 50 frames, render next, if the next textline start on 0, reset textpointer and wait until next frame with update.

enum {
	STATE_WRITING,      // Writing characters 0->40
	STATE_HOLDING       // Waiting 50 frames
};

struct text_writer {
	uint32_t state;
	uint32_t char_count;
	uint32_t text_index;
	uint32_t frame_count;
	uint8_t line_buffer[40];
};

struct text_writer tw;

static void text_writer_init(void) {
	memset(tw.line_buffer, ' ', 40);
}

static void text_writer_update(void) {
	switch(tw.state) {
		case STATE_WRITING:
			if(text[tw.text_index + tw.char_count] == 0) {
				tw.text_index = 0;
				return;
			}

			tw.line_buffer[tw.char_count] = text[tw.text_index + tw.char_count];
			tw.char_count++;

			if(tw.char_count >= 40) {
				tw.char_count = 40;
				tw.frame_count = 0;
				tw.state = STATE_HOLDING;
			}
			break;

		case STATE_HOLDING:
			tw.frame_count++;
			if(tw.frame_count >= 50) {
				tw.char_count = 0;
				tw.text_index += 40;
				tw.frame_count = 0;
				tw.state = STATE_WRITING;
			}
			break;
	}
}

static void text_writer_render(struct platform_state *state) {
	uint32_t *org_dst = BUFFER_PTR(state, CENTER_X(state, (40*8)), 245);
	for(size_t i = 0; i < 40; ++i, org_dst += 8) {
		uint32_t *dst = org_dst;
		uint8_t c = tw.line_buffer[i] - ' ';
		uint8_t *src = font->data + 8 * c;

		for(size_t y = 0; y < font->height; ++y, dst += state->buffer_width, src += font->width) {
			for(size_t x = 0; x < 8; ++x) {
				dst[x] = font->palette[src[x]];
			}
		}
	}
}

static uint32_t bob_palette[32];
static uint32_t black_palette[32];
static struct ugg *bobs[52];

static uint32_t precalc_delays[8] = { 173, 408, 172, 116, 158, 172, 173, 271 };

static uint32_t frame_count;
static uint32_t object_index;

static void render_vector_bobs(struct platform_state *state, uint32_t obj) {
	uint32_t n_coords = objects[obj].count;
	int16_t *object = objects[obj].vec_obj;
	transform_and_project(object, vec_coords, n_coords, angle_x, angle_y, angle_z);
	sort_vec_coord(vec_coords, n_coords);

	struct rect clip_area = { 0, 34, state->buffer_width, 204 };
	for(uint32_t i = 0; i < n_coords; ++i) {
		uint8_t object = vec_coords[i].object;
		uint32_t width_over_two = bobs[object]->width >> 1;
		blit_full_src(state, bobs[object], vec_coords[i].x - width_over_two, (vec_coords[i].y - width_over_two), clip_area, bob_palette);
	}

	angle_x = (angle_x + 3) & 0xff;
	angle_y = (angle_y + 2) & 0xff;
	angle_z = (angle_z + 1) & 0xff;
}



